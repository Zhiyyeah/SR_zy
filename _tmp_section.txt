    fig.savefig(path, dpi=400)
    plt.close(fig)


def save_compact_fourcol_subplot(
    path: str,
    goci_raw: np.ndarray,
    bicubic: np.ndarray,
    sr: np.ndarray,
    hr: np.ndarray,
    band_labels: List[str],
    unit_label: str = TOA_UNIT_LABEL,
    col_texts: Tuple[str, str, str, str] = ("GOCI-II", "Bicubic", "Super Resolution", "HR2"),
    goci_roi_box: Optional[Tuple[int, int, int, int]] = None,  # (y0,y1,x0,x1) to limit view
):
    """Save a 4-column compact figure with tiny gaps and labels inside tiles.

    Layout per row (very small gaps):
        [ GOCI-II | Bicubic | Estimated map | HR2 | colorbar ]

    - Text is drawn inside each image (bottom-left) with a semi-transparent
      background patch plus stroke soÂÖ∂Âú®ÊµÖËâ≤ËÉåÊôØ‰∏ä‰æùÁÑ∂Ê∏ÖÊô∞„Ä?
    - Row markers (a), (b), (c), ... on the first column.
    - Each row has its own colorbar in a slim 5th column.
    """
    import matplotlib.pyplot as plt
    from matplotlib.gridspec import GridSpec

    nband = int(min(5, goci_raw.shape[0], bicubic.shape[0], sr.shape[0], hr.shape[0]))

    # Figure geometry: 4 image columns + 1 colorbar column
    fig = plt.figure(figsize=(15.0, 2.6 * nband))
    gs = GridSpec(
        nrows=nband,
        ncols=5,
        figure=fig,
        # Make colorbar a bit slimmer
        width_ratios=[1, 1, 1, 1, 0.045],
        # Make horizontal gaps even smaller
        wspace=0.006,
        hspace=0.01,
    )

    # Helper to draw a single tile with inside text
    def _draw(ax, img, vmin, vmax, label_text, imshow_kwargs=None):
        if imshow_kwargs is None:
            imshow_kwargs = {}
        im = ax.imshow(img, cmap="viridis", vmin=vmin, vmax=vmax, **imshow_kwargs)
        ax.set_xticks([])
        ax.set_yticks([])
        for spine in ax.spines.values():
            spine.set_visible(False)
        # Text inside the image (bottom-left). Add black outline for readability.
        ax.text(
            0.02,
            0.04,
            label_text,
            transform=ax.transAxes,
            fontsize=9,
            color="w",
            ha="left",
            va="bottom",
            bbox=dict(facecolor="black", alpha=0.35, boxstyle="round,pad=0.2", linewidth=0),
            path_effects=[
                __import__("matplotlib.patheffects").patheffects.withStroke(linewidth=2, foreground="black")
            ],
        )
        return im

    for i in range(nband):
        band_text = band_labels[i] if i < len(band_labels) else f"Band {i+1}"
        raw_b = goci_raw[i]
        bic_b = bicubic[i]
        sr_b = sr[i]
        hr_b = hr[i]

        if goci_roi_box is not None:
            y0, y1, x0, x1 = goci_roi_box
            raw_for_range = raw_b[y0:y1 + 1, x0:x1 + 1]
        else:
            raw_for_range = raw_b
        vmin = float(min(raw_for_range.min(), bic_b.min(), sr_b.min(), hr_b.min()))
        vmax = float(max(raw_for_range.max(), bic_b.max(), sr_b.max(), hr_b.max()))

        ax0 = fig.add_subplot(gs[i, 0])
        ax1 = fig.add_subplot(gs[i, 1])
        ax2 = fig.add_subplot(gs[i, 2])
        ax3 = fig.add_subplot(gs[i, 3])
        cax = fig.add_subplot(gs[i, 4])

        # Draw images with very small gaps and internal labels
        # Column-1: GOCI ROI displayed as a square by compressing vertical to match width
        if goci_roi_box is not None:
            y0, y1, x0, x1 = goci_roi_box
            roi_img = raw_b[y0:y1 + 1, x0:x1 + 1]
            h_roi = (y1 - y0 + 1)
            w_roi = (x1 - x0 + 1)
            im0 = _draw(
                ax0,
                roi_img,
                vmin,
                vmax,
                f"{col_texts[0]} ({band_text})",
                # Make display coordinates a square: width == height == w_roi
                imshow_kwargs=dict(origin="upper", extent=[0, w_roi, w_roi, 0]),
            )
            ax0.set_aspect('equal')
        else:
            im0 = _draw(ax0, raw_b, vmin, vmax, f"{col_texts[0]} ({band_text})")
            ax0.set_aspect('equal')
        # Compute metrics per band (bicubic vs HR, SR vs HR)
        bic_psnr = _psnr_np(bic_b, hr_b)
        bic_r2 = _r2_np(bic_b, hr_b)
        bic_mape = _mape_np(bic_b, hr_b)
        sr_psnr = _psnr_np(sr_b, hr_b)
        sr_r2 = _r2_np(sr_b, hr_b)
        sr_mape = _mape_np(sr_b, hr_b)

        bic_text = f"{col_texts[1]} ({band_text})\nPSNR {bic_psnr:.2f} dB | R2 {bic_r2:.3f} | MAPE {bic_mape:.1f}%"
        sr_text = f"{col_texts[2]} ({band_text})\nPSNR {sr_psnr:.2f} dB | R2 {sr_r2:.3f} | MAPE {sr_mape:.1f}%"

        _draw(ax1, bic_b, vmin, vmax, bic_text)
        _draw(ax2, sr_b, vmin, vmax, sr_text)
        im3 = _draw(ax3, hr_b, vmin, vmax, f"{col_texts[3]} ({band_text})")
        # Keep other columns square (most patches are H==W)
        ax1.set_aspect('equal'); ax2.set_aspect('equal'); ax3.set_aspect('equal')

        # Row marker e.g., (a), (b), ...
        ax0.text(
            0.02,
            0.96,
            f"({chr(97 + i)})",
            transform=ax0.transAxes,
            fontsize=12,
            color="w",
            va="top",
            ha="left",
            path_effects=[
                __import__("matplotlib.patheffects").patheffects.withStroke(linewidth=2, foreground="black")
            ],
            bbox=dict(facecolor="black", alpha=0.35, boxstyle="round,pad=0.2", linewidth=0),
        )

        # Slim colorbar per row
        cb = fig.colorbar(im3, cax=cax)
        cb.ax.tick_params(labelsize=7, pad=1)
        # Thinner outline so it looks lighter
        try:
            cb.outline.set_linewidth(0.6)
        except Exception:
            pass

        # Add unit label next to colorbar
        try:
            cb.set_label(unit_label, fontsize=7, rotation=270, labelpad=6)
            cb.ax.yaxis.set_label_position("right")
        except Exception:
            pass

        # Slightly shorten the colorbar vertically (shrink and recenter)
        try:
            bbox = cax.get_position()
            shrink = 0.9  # keep 90% height
            new_h = bbox.height * shrink
            new_y = bbox.y0 + (bbox.height - new_h) / 2.0
            cax.set_position([bbox.x0, new_y, bbox.width, new_h])
        except Exception:
            pass

    # Keep margins small but shift a bit left so the colorbar is fully visible
    fig.subplots_adjust(left=0.01, right=0.975, top=0.99, bottom=0.01)

    os.makedirs(os.path.dirname(path), exist_ok=True)
    fig.savefig(path, dpi=400)
    plt.close(fig)


@torch.no_grad()
def main():
    t0 = time.time()
    device = get_device()
