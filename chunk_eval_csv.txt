

@torch.no_grad()
def main():
    device = get_device()
    model = create_model(in_channels=5, out_channels=5).to(device)
    load_checkpoint(model, WEIGHTS, map_location=device)
    model.eval()

    ds = PairTifDataset(lr_dir=TEST_LR_DIR, hr_dir=TEST_HR_DIR, require_bands=5)
    os.makedirs(SAVE_DIR, exist_ok=True)
    # Prepare metrics CSV
    os.makedirs(SAVE_DIR, exist_ok=True)
    if not os.path.exists(METRICS_CSV):
        with open(METRICS_CSV, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow([
                "filename",
                "bicubic_psnr_mean",
                "sr_psnr_mean",
                "bicubic_psnr_b1","bicubic_psnr_b2","bicubic_psnr_b3","bicubic_psnr_b4","bicubic_psnr_b5",
                "sr_psnr_b1","sr_psnr_b2","sr_psnr_b3","sr_psnr_b4","sr_psnr_b5",
            ])

    saved = 0
    skipped_no_bbox = 0

    for i in tqdm(range(len(ds)), desc="eval-4col"):
        lr_t, hr_t, name = ds[i]
        lr_t = lr_t.unsqueeze(0).to(device)
        hr_t = hr_t.unsqueeze(0).to(device)
        sr = model(lr_t)

        sr_np = sr.squeeze(0).cpu().numpy()
        hr_np = hr_t.squeeze(0).cpu().numpy()
        lr_np = lr_t.squeeze(0).cpu().numpy()

        # Find GOCI original and read ROI by patch bounds (WGS84)
        scene_core = scene_id_from_patch_name(name)
        nc_path = find_nc_for_scene(GOCI_ORI_ROOT, scene_core)
        if VERBOSE_SKIP_LOG:
            if nc_path:
                tqdm.write(f"[info] using GOCI nc: {nc_path}")
            else:
                tqdm.write(f"[warn] GOCI nc not found for scene={scene_core}")
        # get LR patch absolute path
        try:
            lr_full, _ = ds.files[i]
        except Exception:
            lr_full = os.path.join(TEST_LR_DIR, os.path.basename(name))
        try:
            bbox_wgs84, crs_str = get_patch_bounds_wgs84(lr_full)
        except Exception:
            bbox_wgs84 = None

        # Read GOCI full scene + lat/lon (do not crop); compute ROI indices to limit display
        # Attempt to read GOCI, but do not abort the figure if it fails.
        goci_full = None
        roi_box = None
        goci_label = "GOCI-II"
        if bbox_wgs84 is None:
            if VERBOSE_SKIP_LOG:
                tqdm.write(f"[warn] no bbox for file={lr_full}; cannot window GOCI display")
            skipped_no_bbox += 1
        if nc_path is not None:
            try:
                goci_full, goci_lat, goci_lon = read_nc_full_and_latlon(nc_path)
                if bbox_wgs84 is not None:
                    y0, y1, x0, x1 = roi_indices_from_latlon(goci_lat, goci_lon, bbox_wgs84)
                    roi_box = (y0, y1, x0, x1)
                if VERBOSE_SKIP_LOG:
                    tqdm.write(f"[ok] GOCI read; roi={roi_box}")
            except Exception as e:
                if VERBOSE_SKIP_LOG:
                    tqdm.write(f"[warn] read nc or roi failure for scene={scene_core}: {type(e).__name__}: {e}")
                goci_label = "GOCI read failed"
        else:
            goci_label = "GOCI not found"

        # Column-1: GOCI full (if available) with display window limited to ROI
        # If not available, fall back to zeros with same shape as LR for rendering, with label changed.
        if goci_full is None:
            # Form a blank canvas with same HxW as LR for consistent tiling
            goci_raw = np.zeros_like(lr_np)
        else:
            goci_raw = goci_full
        # Column-2: use the LR TIFF patch directly (no interpolation in eval)
        bicubic_np = lr_np
        target_c, target_h, target_w = sr_np.shape

        title = scene_core
        if bbox_wgs84 is not None:
            xmin, ymin, xmax, ymax = bbox_wgs84
            title += f" | WGS84 [{xmin:.5f},{ymin:.5f}]â€“[{xmax:.5f},{ymax:.5f}]"

        # Use patch filename to avoid overwrite across patches in same scene
        patch_base = os.path.splitext(os.path.basename(name))[0]
        # Save compact 4-column figure (tiny gaps, labels inside)
        out_png_compact = os.path.join(SAVE_DIR, f"{patch_base}_compare_compact.png")
        try:
            save_compact_fourcol_subplot(
                out_png_compact,
                goci_raw,
                bicubic_np,
                sr_np,
                hr_np,
                BAND_LABELS,
                col_texts=(goci_label, "Interpolated GOCI", "Super Resolution", "Landsat"),
                goci_roi_box=roi_box,
            )
            saved += 1
        except Exception:
            # fallback to previous 4-col figure if compact fails for any reason
            out_png = os.path.join(SAVE_DIR, f"{patch_base}_compare_4col.png")
            save_four_col_figure(out_png, goci_raw, bicubic_np, sr_np, hr_np, BAND_LABELS, title)
            saved += 1

        # Compute per-band PSNRs (bicubic vs HR, SR vs HR) and append to CSV
        try:
            nb = int(min(5, bicubic_np.shape[0], sr_np.shape[0], hr_np.shape[0]))
            bic_psnrs = []
            sr_psnrs = []
            for bi in range(nb):
                bic_psnrs.append(_psnr_np(bicubic_np[bi], hr_np[bi]))
                sr_psnrs.append(_psnr_np(sr_np[bi], hr_np[bi]))
            # pad to length 5 for consistent columns
            while len(bic_psnrs) < 5:
                bic_psnrs.append(float('nan'))
            while len(sr_psnrs) < 5:
                sr_psnrs.append(float('nan'))
            with open(METRICS_CSV, "a", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                writer.writerow([
                    os.path.basename(name),
                    float(np.nanmean(bic_psnrs)),
                    float(np.nanmean(sr_psnrs)),
                    *[float(x) for x in bic_psnrs[:5]],
                    *[float(x) for x in sr_psnrs[:5]],
                ])
        except Exception as e:
            if VERBOSE_SKIP_LOG:
                tqdm.write(f"[warn] failed to write metrics CSV for {name}: {type(e).__name__}: {e}")
    if VERBOSE_SKIP_LOG:
        tqdm.write(f"[summary] saved={saved}, no_bbox={skipped_no_bbox}")

if __name__ == "__main__":
    main()
