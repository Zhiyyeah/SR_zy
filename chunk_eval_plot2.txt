        # Draw images with very small gaps and internal labels
        # Column-1: GOCI ROI displayed as a square by compressing vertical to match width
        if goci_roi_box is not None:
            y0, y1, x0, x1 = goci_roi_box
            roi_img = raw_b[y0:y1 + 1, x0:x1 + 1]
            h_roi = (y1 - y0 + 1)
            w_roi = (x1 - x0 + 1)
            im0 = _draw(
                ax0,
                roi_img,
                vmin,
                vmax,
                f"{col_texts[0]} ({band_text})",
                # Make display coordinates a square: width == height == w_roi
                imshow_kwargs=dict(origin="upper", extent=[0, w_roi, w_roi, 0]),
            )
            ax0.set_aspect('equal')
        else:
            im0 = _draw(ax0, raw_b, vmin, vmax, f"{col_texts[0]} ({band_text})")
            ax0.set_aspect('equal')
        _draw(ax1, bic_b, vmin, vmax, f"{col_texts[1]} ({band_text})")
        _draw(ax2, sr_b, vmin, vmax, f"{col_texts[2]} ({band_text})")
        im3 = _draw(ax3, hr_b, vmin, vmax, f"{col_texts[3]} ({band_text})")
        # Keep other columns square (most patches are H==W)
        ax1.set_aspect('equal'); ax2.set_aspect('equal'); ax3.set_aspect('equal')

        # Row marker e.g., (a), (b), ...
        ax0.text(
            0.02,
            0.96,
            f"({chr(97 + i)})",
            transform=ax0.transAxes,
            fontsize=12,
            color="w",
            va="top",
            ha="left",
            path_effects=[
                __import__("matplotlib.patheffects").patheffects.withStroke(linewidth=2, foreground="black")
            ],
            bbox=dict(facecolor="black", alpha=0.35, boxstyle="round,pad=0.2", linewidth=0),
        )

        # Slim colorbar per row
        cb = fig.colorbar(im3, cax=cax)
        cb.ax.tick_params(labelsize=7, pad=1)
        # Thinner outline so it looks lighter
        try:
            cb.outline.set_linewidth(0.6)
        except Exception:
            pass

        # Add unit label next to colorbar
        try:
            cb.set_label(unit_label, fontsize=7, rotation=270, labelpad=6)
            cb.ax.yaxis.set_label_position("right")
        except Exception:
            pass

        # Slightly shorten the colorbar vertically (shrink and recenter)
        try:
            bbox = cax.get_position()
            shrink = 0.9  # keep 90% height
            new_h = bbox.height * shrink
            new_y = bbox.y0 + (bbox.height - new_h) / 2.0
            cax.set_position([bbox.x0, new_y, bbox.width, new_h])
        except Exception:
            pass

    # Keep margins small but shift a bit left so the colorbar is fully visible
    fig.subplots_adjust(left=0.01, right=0.975, top=0.99, bottom=0.01)

    os.makedirs(os.path.dirname(path), exist_ok=True)
    fig.savefig(path, dpi=400)
    plt.close(fig)


@torch.no_grad()
def main():
    device = get_device()
    model = create_model(in_channels=5, out_channels=5).to(device)
    load_checkpoint(model, WEIGHTS, map_location=device)
    model.eval()

    ds = PairTifDataset(lr_dir=LR_DIR, hr_dir=HR_DIR, require_bands=5)
    os.makedirs(SAVE_DIR, exist_ok=True)

    saved = 0
    skipped_no_bbox = 0

    for i in tqdm(range(len(ds)), desc="eval-4col"):
        lr_t, hr_t, name = ds[i]
        lr_t = lr_t.unsqueeze(0).to(device)
        hr_t = hr_t.unsqueeze(0).to(device)
        sr = model(lr_t)

        sr_np = sr.squeeze(0).cpu().numpy()
        hr_np = hr_t.squeeze(0).cpu().numpy()
        lr_np = lr_t.squeeze(0).cpu().numpy()

        # Find GOCI original and read ROI by patch bounds (WGS84)
        scene_core = scene_id_from_patch_name(name)
        nc_path = find_nc_for_scene(GOCI_ORI_ROOT, scene_core)
        if VERBOSE_SKIP_LOG:
            if nc_path:
                tqdm.write(f"[info] using GOCI nc: {nc_path}")
            else:
