import os
import re
from typing import Optional, Tuple, List

import numpy as np
import torch
import rasterio
from rasterio.warp import transform_bounds
from tqdm import tqdm
import matplotlib
matplotlib.use('Agg')  # éžäº¤äº’å¼åŽç«¯ï¼Œä¸ç”¨Tkinter

from .data_loader import PairTifDataset
from .model_attention import create_model
from .utils import get_device, load_checkpoint
from .metrics import psnr as psnr_fn


# --------------------
# Config (edit as needed)
# --------------------
LR_DIR = r"D:\Py_Code\img_match\SR_Imagery\tif\LR"
HR_DIR = r"D:\Py_Code\img_match\SR_Imagery\tif\HR"
WEIGHTS = "Unet_organized/Unet_SA_Claude_SameRes/outputs/run_auto/models/best.pth"##è®°ç€æ”?
SAVE_DIR = "Unet_organized/Unet_SA_Claude_SameRes/outputs/run_auto/eval/viz4"
GOCI_ORI_ROOT = r"D:\Py_Code\img_match\batch_outputs"
BAND_LABELS = ["443 nm", "490 nm", "555 nm", "660 nm", "865 nm"]

# If LR and SR have identical spatial size (SameRes), bicubic upsample equals
# the original. Set this>1 (e.g., 2) to build a blurred bicubic baseline by
# downsampling then bicubic upsampling back to the original size.
BICUBIC_BASELINE_FACTOR = 1  # 1 = disable; 2 or 4 = enable baseline blur

# Colorbar unit label
TOA_UNIT_LABEL = "TOA radiance (WÂ·mâ»Â²Â·srâ»Â¹Â·Âµmâ»Â?"
VERBOSE_SKIP_LOG = True  # print reasons when a sample is skipped


# --------------------
# Helpers
# --------------------
def scene_id_from_patch_name(name: str) -> str:
    base = os.path.splitext(name)[0]
    low = base.lower()
    if low.startswith("lr_"):
        base = base[len("LR_"):]
    if low.startswith("hr_"):
        base = base[len("HR_"):]
    return re.sub(r"_r\d+_c\d+$", "", base, flags=re.IGNORECASE)


def find_nc_for_scene(root: str, scene_core: str) -> Optional[str]:
    """Find the GOCI NetCDF for a given scene.

    Expected layout (given by user):
        <root>/<scene_core>/GK2_GOCI2_L1B_..._subset_footprint.nc

    Strategy:
        1) Look for any *.nc in the exact subfolder <root>/<scene_core>/ matching
           pattern '*subset_footprint.nc'.
        2) If none, pick the first *.nc inside that folder.
        3) As a last resort, search recursively for a file whose dir contains the scene_core.
    """
    if not root or not os.path.isdir(root):
        return None

    scene_dir = os.path.join(root, scene_core)
    if os.path.isdir(scene_dir):
        # Prefer files that contain 'subset_footprint.nc'
        specific: List[str] = []
        any_nc: List[str] = []
        for r, _, files in os.walk(scene_dir):
            for f in files:
                if f.lower().endswith('.nc'):
                    p = os.path.join(r, f)
                    any_nc.append(p)
                    if 'subset_footprint.nc' in f.lower():
                        specific.append(p)
        if specific:
            # Return the lexicographically first for determinism
            return sorted(specific)[0]
        if any_nc:
            return sorted(any_nc)[0]

    # Fallback: search under root for any folder with scene_core in its name
    for r, dirs, files in os.walk(root):
        for d in dirs:
            if scene_core.lower() in d.lower():
                dd = os.path.join(r, d)
                cands = [os.path.join(dd, f) for f in os.listdir(dd) if f.lower().endswith('.nc')]
                if cands:
                    # Prefer subset_footprint
                    spec = [p for p in cands if 'subset_footprint.nc' in os.path.basename(p).lower()]
                    if spec:
                        return sorted(spec)[0]
                    return sorted(cands)[0]
    return None


def get_patch_bounds_wgs84(tif_path: str) -> Tuple[Tuple[float, float, float, float], str]:
    with rasterio.open(tif_path) as ds:
        b = ds.bounds
        crs = ds.crs
    b_wgs84 = transform_bounds(crs, "EPSG:4326", *b, densify_pts=21)
    return b_wgs84, str(crs)


def _resize_chw(chw: np.ndarray, out_h: int, out_w: int) -> np.ndarray:
    c, h, w = chw.shape
    if (h, w) == (out_h, out_w):
        return chw
    try:
        from skimage.transform import resize  # type: ignore
        out = np.stack([
            resize(chw[i], (out_h, out_w), order=1, preserve_range=True, anti_aliasing=False).astype(np.float32)
            for i in range(c)
        ], axis=0)
        return out
    except Exception:
        ys = (np.linspace(0, h - 1, out_h)).round().astype(int)
        xs = (np.linspace(0, w - 1, out_w)).round().astype(int)
        return chw[:, ys][:, :, xs]


def _resize_chw_order(chw: np.ndarray, out_h: int, out_w: int, order: int = 3) -> np.ndarray:
    """Resize CHW to target size with specified interpolation order.
    order=3 means bicubic; order=1 bilinear.
    """
    c, h, w = chw.shape
    if (h, w) == (out_h, out_w):
        return chw
    try:
        from skimage.transform import resize  # type: ignore
        out = np.stack([
            resize(chw[i], (out_h, out_w), order=order, preserve_range=True, anti_aliasing=False).astype(np.float32)
            for i in range(c)
        ], axis=0)
        return out
    except Exception:
        # Fallback nearest grid sampling
        ys = (np.linspace(0, h - 1, out_h)).round().astype(int)
        xs = (np.linspace(0, w - 1, out_w)).round().astype(int)
        return chw[:, ys][:, :, xs]


def read_nc_roi(nc_path: str, bbox_wgs84: Tuple[float, float, float, float], out_shape: Optional[Tuple[int, int, int]] = None) -> np.ndarray:
    """Read ROI from GOCI NetCDF using WGS84 bbox. Returns CHW float32.
    Uses netCDF4 directly to avoid heavy deps.
    """
    try:
        from netCDF4 import Dataset  # type: ignore
    except Exception:
        raise RuntimeError("netCDF4 not available (pip install netCDF4)")

    ds = Dataset(nc_path, "r")
    # Find lat/lon variables
    lat_name = None
    lon_name = None
    for name, var in ds.variables.items():
        n = name.lower()
        if lat_name is None and ("lat" in n or "latitude" in n):
            lat_name = name
        if lon_name is None and ("lon" in n or "longitude" in n):
            lon_name = name
    if lat_name is None or lon_name is None:
        raise RuntimeError("No lat/lon variables in NetCDF")
    lat = ds.variables[lat_name][:]
    lon = ds.variables[lon_name][:]
    minx, miny, maxx, maxy = bbox_wgs84

    def _roi_indices(lat, lon):
        if getattr(lat, "ndim", 0) == 1 and getattr(lon, "ndim", 0) == 1:
            ys = np.where((lat >= miny) & (lat <= maxy))[0]
            xs = np.where((lon >= minx) & (lon <= maxx))[0]
            if ys.size == 0 or xs.size == 0:
                raise RuntimeError("ROI outside lat/lon grid")
            return ys.min(), ys.max(), xs.min(), xs.max()
        else:
            mask = (lat >= miny) & (lat <= maxy) & (lon >= minx) & (lon <= maxx)
            ys, xs = np.where(mask)
            if ys.size == 0 or xs.size == 0:
                raise RuntimeError("ROI mask empty for lat/lon grid")
            return ys.min(), ys.max(), xs.min(), xs.max()

    y0, y1, x0, x1 = _roi_indices(lat, lon)

    # Pick 5 band variables (prefer names with expected wavelengths)
    order = ["443", "490", "555", "660", "865"]
    band_vars: List[str] = []
    for w in order:
        found = None
        for name, var in ds.variables.items():
            if name in (lat_name, lon_name):
                continue
            if getattr(var, "ndim", 0) == 2 and w in name:
                found = name
                break
        if found is not None:
            band_vars.append(found)
    if len(band_vars) < 5:
        # fallback: first 5 2D variables excluding lat/lon
