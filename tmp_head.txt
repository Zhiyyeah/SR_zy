import os
import re
from typing import Optional, Tuple, List

import numpy as np
import torch
import rasterio
from rasterio.warp import transform_bounds
from tqdm import tqdm

from .data_loader import PairTifDataset
from .model_attention import create_model
from .utils import get_device, load_checkpoint
from .metrics import psnr as psnr_fn


# --------------------
# Config (edit as needed)
# --------------------
LR_DIR = r"D:\Py_Code\img_match\SR_Imagery\tif\LR"
HR_DIR = r"D:\Py_Code\img_match\SR_Imagery\tif\HR"
WEIGHTS = "Unet_organized/Unet_SA_Claude_SameRes/outputs/run_auto/models/best.pth"##è®°ç€æ”?
SAVE_DIR = "Unet_organized/Unet_SA_Claude_SameRes/outputs/run_auto/eval/viz4"
GOCI_ORI_ROOT = r"D:\Py_Code\img_match\batch_outputs"
BAND_LABELS = ["443 nm", "490 nm", "555 nm", "660 nm", "865 nm"]

# If LR and SR have identical spatial size (SameRes), bicubic upsample equals
# the original. Set this>1 (e.g., 2) to build a blurred bicubic baseline by
# downsampling then bicubic upsampling back to the original size.
BICUBIC_BASELINE_FACTOR = 1  # 1 = disable; 2 or 4 = enable baseline blur

# Colorbar unit label
TOA_UNIT_LABEL = "TOA radiance (WÂ·mâ»Â²Â·srâ»Â¹Â·Âµmâ»Â?"
VERBOSE_SKIP_LOG = True  # print reasons when a sample is skipped


# --------------------
# Helpers
# --------------------
def scene_id_from_patch_name(name: str) -> str:
    base = os.path.splitext(name)[0]
    low = base.lower()
    if low.startswith("lr_"):
        base = base[len("LR_"):]
    if low.startswith("hr_"):
        base = base[len("HR_"):]
    return re.sub(r"_r\d+_c\d+$", "", base, flags=re.IGNORECASE)


def find_nc_for_scene(root: str, scene_core: str) -> Optional[str]:
    """Find the GOCI NetCDF for a given scene.

    Expected layout (given by user):
        <root>/<scene_core>/GK2_GOCI2_L1B_..._subset_footprint.nc

    Strategy:
        1) Look for any *.nc in the exact subfolder <root>/<scene_core>/ matching
           pattern '*subset_footprint.nc'.
        2) If none, pick the first *.nc inside that folder.
        3) As a last resort, search recursively for a file whose dir contains the scene_core.
    """
    if not root or not os.path.isdir(root):
        return None

    scene_dir = os.path.join(root, scene_core)
    if os.path.isdir(scene_dir):
        # Prefer files that contain 'subset_footprint.nc'
        specific: List[str] = []
        any_nc: List[str] = []
        for r, _, files in os.walk(scene_dir):
            for f in files:
                if f.lower().endswith('.nc'):
                    p = os.path.join(r, f)
                    any_nc.append(p)
                    if 'subset_footprint.nc' in f.lower():
                        specific.append(p)
        if specific:
            # Return the lexicographically first for determinism
            return sorted(specific)[0]
        if any_nc:
            return sorted(any_nc)[0]

    # Fallback: search under root for any folder with scene_core in its name
    for r, dirs, files in os.walk(root):
        for d in dirs:
            if scene_core.lower() in d.lower():
                dd = os.path.join(r, d)
                cands = [os.path.join(dd, f) for f in os.listdir(dd) if f.lower().endswith('.nc')]
                if cands:
                    # Prefer subset_footprint
                    spec = [p for p in cands if 'subset_footprint.nc' in os.path.basename(p).lower()]
                    if spec:
                        return sorted(spec)[0]
                    return sorted(cands)[0]
    return None


def get_patch_bounds_wgs84(tif_path: str) -> Tuple[Tuple[float, float, float, float], str]:
    with rasterio.open(tif_path) as ds:
        b = ds.bounds
        crs = ds.crs
    b_wgs84 = transform_bounds(crs, "EPSG:4326", *b, densify_pts=21)
    return b_wgs84, str(crs)


def _resize_chw(chw: np.ndarray, out_h: int, out_w: int) -> np.ndarray:
    c, h, w = chw.shape
    if (h, w) == (out_h, out_w):
        return chw
    try:
        from skimage.transform import resize  # type: ignore
        out = np.stack([
            resize(chw[i], (out_h, out_w), order=1, preserve_range=True, anti_aliasing=False).astype(np.float32)
            for i in range(c)
        ], axis=0)
        return out
    except Exception:
        ys = (np.linspace(0, h - 1, out_h)).round().astype(int)
        xs = (np.linspace(0, w - 1, out_w)).round().astype(int)
        return chw[:, ys][:, :, xs]


def _resize_chw_order(chw: np.ndarray, out_h: int, out_w: int, order: int = 3) -> np.ndarray:
    """Resize CHW to target size with specified interpolation order.
    order=3 means bicubic; order=1 bilinear.
    """
    c, h, w = chw.shape
    if (h, w) == (out_h, out_w):
        return chw
    try:
        from skimage.transform import resize  # type: ignore
        out = np.stack([
            resize(chw[i], (out_h, out_w), order=order, preserve_range=True, anti_aliasing=False).astype(np.float32)
            for i in range(c)
        ], axis=0)
        return out
    except Exception:
        # Fallback nearest grid sampling
        ys = (np.linspace(0, h - 1, out_h)).round().astype(int)
        xs = (np.linspace(0, w - 1, out_w)).round().astype(int)
        return chw[:, ys][:, :, xs]


def read_nc_roi(nc_path: str, bbox_wgs84: Tuple[float, float, float, float], out_shape: Optional[Tuple[int, int, int]] = None) -> np.ndarray:
    """Read ROI from GOCI NetCDF using WGS84 bbox. Returns CHW float32.
    Uses netCDF4 directly to avoid heavy deps.
    """
    try:
        from netCDF4 import Dataset  # type: ignore
    except Exception:
        raise RuntimeError("netCDF4 not available (pip install netCDF4)")

    ds = Dataset(nc_path, "r")
    # Find lat/lon variables
    lat_name = None
    lon_name = None
    for name, var in ds.variables.items():
        n = name.lower()
        if lat_name is None and ("lat" in n or "latitude" in n):
            lat_name = name
        if lon_name is None and ("lon" in n or "longitude" in n):
            lon_name = name
    if lat_name is None or lon_name is None:
        raise RuntimeError("No lat/lon variables in NetCDF")
    lat = ds.variables[lat_name][:]
    lon = ds.variables[lon_name][:]
    minx, miny, maxx, maxy = bbox_wgs84

    def _roi_indices(lat, lon):
        if getattr(lat, "ndim", 0) == 1 and getattr(lon, "ndim", 0) == 1:
            ys = np.where((lat >= miny) & (lat <= maxy))[0]
            xs = np.where((lon >= minx) & (lon <= maxx))[0]
            if ys.size == 0 or xs.size == 0:
                raise RuntimeError("ROI outside lat/lon grid")
            return ys.min(), ys.max(), xs.min(), xs.max()
        else:
            mask = (lat >= miny) & (lat <= maxy) & (lon >= minx) & (lon <= maxx)
            ys, xs = np.where(mask)
            if ys.size == 0 or xs.size == 0:
                raise RuntimeError("ROI mask empty for lat/lon grid")
            return ys.min(), ys.max(), xs.min(), xs.max()

    y0, y1, x0, x1 = _roi_indices(lat, lon)

    # Pick 5 band variables (prefer names with expected wavelengths)
    order = ["443", "490", "555", "660", "865"]
    band_vars: List[str] = []
    for w in order:
        found = None
        for name, var in ds.variables.items():
            if name in (lat_name, lon_name):
                continue
            if getattr(var, "ndim", 0) == 2 and w in name:
                found = name
                break
        if found is not None:
            band_vars.append(found)
    if len(band_vars) < 5:
        # fallback: first 5 2D variables excluding lat/lon
        band_vars = []
        for name, var in ds.variables.items():
            if name in (lat_name, lon_name):
                continue
            if getattr(var, "ndim", 0) == 2:
                band_vars.append(name)
            if len(band_vars) >= 5:
                break
    if len(band_vars) < 5:
        raise RuntimeError("Not enough 2D band variables in NetCDF")

    data = []
    for name in band_vars[:5]:
        arr = ds.variables[name][y0:y1 + 1, x0:x1 + 1].astype(np.float32)
        data.append(arr)
    data = np.stack(data, axis=0)  # (C,H,W)

    if out_shape is not None:
        c, h, w = out_shape
        data = _resize_chw(data, h, w)
        if data.shape[0] < c:
            pad = np.zeros((c - data.shape[0], h, w), dtype=np.float32)
            data = np.concatenate([data, pad], axis=0)
    return data


def read_nc_full_and_latlon(nc_path: str) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Read full GOCI NetCDF bands plus lat/lon grids.

    Returns:
        data: (C,H,W) float32 for 5 bands (preferred wavelengths order)
        lat:  (H,W) or (H,) latitude grid
        lon:  (H,W) or (W,) longitude grid
    """
    try:
        from netCDF4 import Dataset  # type: ignore
    except Exception:
        raise RuntimeError("netCDF4 not available (pip install netCDF4)")

    ds = Dataset(nc_path, "r")

    # Helper: recursively iterate variables with their full path
    def _iter_vars(g, prefix=""):
        for name, var in g.variables.items():
            yield prefix + name, var
        for sub, sg in g.groups.items():
            yield from _iter_vars(sg, prefix + sub + "/")

    # 1) Latitude/Longitude: prefer navigation_data group
    lat = lon = None
    if "navigation_data" in ds.groups:
        nav = ds.groups["navigation_data"]
        if "latitude" in nav.variables and "longitude" in nav.variables:
            lat = nav.variables["latitude"][:]
            lon = nav.variables["longitude"][:]
    # Fallback: search recursively
    if lat is None or lon is None:
        for full_name, var in _iter_vars(ds):
            lname = full_name.lower()
            if lat is None and (lname.endswith("latitude") or "/latitude" in lname or "latitude" in lname):
                lat = var[:]
            if lon is None and (lname.endswith("longitude") or "/longitude" in lname or "longitude" in lname):
                lon = var[:]
            if lat is not None and lon is not None:
                break
    if lat is None or lon is None:
        raise RuntimeError("No lat/lon variables in NetCDF (including navigation_data group)")

    # 2) Pick 5 band variables in preferred order, search recursively (exclude lat/lon)
    order = ["443", "490", "555", "660", "865"]
    chosen_vars: List[np.ndarray] = []
    for w in order:
        found_arr = None
        for full_name, var in _iter_vars(ds):
            lname = full_name.lower()
            if "latitude" in lname or "longitude" in lname:
                continue
            if getattr(var, "ndim", 0) == 2 and w in lname:
                found_arr = var[:].astype(np.float32)
                break
        if found_arr is not None:
            chosen_vars.append(found_arr)
    if len(chosen_vars) < 5:
        # fallback: take first 5 2D non-latlon variables found recursively
        chosen_vars = []
        for full_name, var in _iter_vars(ds):
            lname = full_name.lower()
            if "latitude" in lname or "longitude" in lname:
                continue
            if getattr(var, "ndim", 0) == 2:
                chosen_vars.append(var[:].astype(np.float32))
            if len(chosen_vars) >= 5:
                break
    if len(chosen_vars) < 5:
        raise RuntimeError("Not enough 2D band variables in NetCDF (recursive search)")

    data = np.stack(chosen_vars[:5], axis=0)
    return data, np.array(lat), np.array(lon)


def roi_indices_from_latlon(
    lat: np.ndarray, lon: np.ndarray, bbox_wgs84: Tuple[float, float, float, float]
) -> Tuple[int, int, int, int]:
    """Compute y0,y1,x0,x1 indices of ROI based on lat/lon arrays and bbox.
    Handles lat/lon in 1D or 2D.
    """
    minx, miny, maxx, maxy = bbox_wgs84
    if getattr(lat, "ndim", 0) == 1 and getattr(lon, "ndim", 0) == 1:
        ys = np.where((lat >= miny) & (lat <= maxy))[0]
        xs = np.where((lon >= minx) & (lon <= maxx))[0]
        if ys.size == 0 or xs.size == 0:
            raise RuntimeError("ROI outside lat/lon grid")
        return int(ys.min()), int(ys.max()), int(xs.min()), int(xs.max())
    else:
        mask = (lat >= miny) & (lat <= maxy) & (lon >= minx) & (lon <= maxx)
        ys, xs = np.where(mask)
        if ys.size == 0 or xs.size == 0:
            raise RuntimeError("ROI mask empty for lat/lon grid")
        return int(ys.min()), int(ys.max()), int(xs.min()), int(xs.max())


def save_four_col_figure(path: str, goci_raw: np.ndarray, interp: np.ndarray, sr: np.ndarray, hr: np.ndarray,
                         band_labels: List[str], title: str):
    import matplotlib.pyplot as plt

    c = min(5, sr.shape[0], hr.shape[0], goci_raw.shape[0], interp.shape[0])
    # Bigger canvas; explicit spacing to avoid overlap
    fig, axes = plt.subplots(
        nrows=c,
        ncols=4,
        figsize=(14.0, 2.6 * c),  # increase size
        gridspec_kw=dict(wspace=0.25, hspace=0.35),  # a bit tighter but readable
        constrained_layout=False,
    )
    try:
        fig.suptitle(title, fontsize=12, y=0.985)
    except Exception:
        pass

    for i in range(c):
        raw_b = goci_raw[i]
        int_b = interp[i]
        sr_b = sr[i]
        hr_b = hr[i]
        vmin = float(min(raw_b.min(), int_b.min(), sr_b.min(), hr_b.min()))
        vmax = float(max(raw_b.max(), int_b.max(), sr_b.max(), hr_b.max()))
        label = band_labels[i] if i < len(band_labels) else f"Band {i+1}"

        ax = axes[i, 0]
        im0 = ax.imshow(raw_b, cmap="viridis", vmin=vmin, vmax=vmax)
        ax.set_title(f"GOCI Raw - {label}", fontsize=10, pad=4)
        ax.axis("off")

        ax = axes[i, 1]
        im1 = ax.imshow(int_b, cmap="viridis", vmin=vmin, vmax=vmax)
        ax.set_title(f"Interp - {label}", fontsize=10, pad=4)
        ax.axis("off")

        # SR band PSNR vs HR
        sr_t = torch.from_numpy(sr_b[None, None, ...])
        hr_t = torch.from_numpy(hr_b[None, None, ...])
        bpsnr = psnr_fn(sr_t, hr_t)

        ax = axes[i, 2]
        im2 = ax.imshow(sr_b, cmap="viridis", vmin=vmin, vmax=vmax)
        ax.set_title(f"SR - {label} | PSNR {bpsnr:.2f} dB", fontsize=10, pad=4)
        ax.axis("off")

        ax = axes[i, 3]
        im3 = ax.imshow(hr_b, cmap="viridis", vmin=vmin, vmax=vmax)
        ax.set_title(f"HR - {label}", fontsize=10, pad=4)
        ax.axis("off")
        # Wider colorbar so it's visible
        cbar = fig.colorbar(im3, ax=ax, fraction=0.05, pad=0.02, aspect=35)
        cbar.ax.tick_params(labelsize=8)

    os.makedirs(os.path.dirname(path), exist_ok=True)
    # Extra padding to respect suptitle
    fig.subplots_adjust(top=0.92, bottom=0.06, left=0.06, right=0.98)
    fig.savefig(path, dpi=400)
    plt.close(fig)


def save_compact_fourcol_subplot(
    path: str,
    goci_raw: np.ndarray,
    bicubic: np.ndarray,
    sr: np.ndarray,
    hr: np.ndarray,
    band_labels: List[str],
    unit_label: str = TOA_UNIT_LABEL,
    col_texts: Tuple[str, str, str, str] = ("GOCI-II", "Bicubic", "Super Resolution", "HR2"),
    goci_roi_box: Optional[Tuple[int, int, int, int]] = None,  # (y0,y1,x0,x1) to limit view
):
    """Save a 4-column compact figure with tiny gaps and labels inside tiles.

    Layout per row (very small gaps):
        [ GOCI-II | Bicubic | Estimated map | HR2 | colorbar ]

    - Text is drawn inside each image (bottom-left) with a semi-transparent
      background patch plus stroke soå…¶åœ¨æµ…è‰²èƒŒæ™¯ä¸Šä¾ç„¶æ¸…æ™°ã€?
    - Row markers (a), (b), (c), ... on the first column.
    - Each row has its own colorbar in a slim 5th column.
    """
    import matplotlib.pyplot as plt
    from matplotlib.gridspec import GridSpec

    nband = int(min(5, goci_raw.shape[0], bicubic.shape[0], sr.shape[0], hr.shape[0]))

    # Figure geometry: 4 image columns + 1 colorbar column
    fig = plt.figure(figsize=(15.0, 2.6 * nband))
    gs = GridSpec(
        nrows=nband,
        ncols=5,
        figure=fig,
        # Make colorbar a bit slimmer
        width_ratios=[1, 1, 1, 1, 0.045],
        # Make horizontal gaps even smaller
        wspace=0.006,
        hspace=0.01,
    )

    # Helper to draw a single tile with inside text
    def _draw(ax, img, vmin, vmax, label_text):
        im = ax.imshow(img, cmap="viridis", vmin=vmin, vmax=vmax)
        ax.set_xticks([])
        ax.set_yticks([])
        for spine in ax.spines.values():
            spine.set_visible(False)
        # Text inside the image (bottom-left). Add black outline for readability.
        ax.text(
            0.02,
            0.04,
            label_text,
            transform=ax.transAxes,
            fontsize=10,
            color="w",
            ha="left",
            va="bottom",
            bbox=dict(facecolor="black", alpha=0.35, boxstyle="round,pad=0.2", linewidth=0),
            path_effects=[
                __import__("matplotlib.patheffects").patheffects.withStroke(linewidth=2, foreground="black")
            ],
        )
        return im

    for i in range(nband):
        band_text = band_labels[i] if i < len(band_labels) else f"Band {i+1}"
        raw_b = goci_raw[i]
        bic_b = bicubic[i]
        sr_b = sr[i]
        hr_b = hr[i]

        if goci_roi_box is not None:
            y0, y1, x0, x1 = goci_roi_box
            raw_for_range = raw_b[y0:y1 + 1, x0:x1 + 1]
        else:
            raw_for_range = raw_b
        vmin = float(min(raw_for_range.min(), bic_b.min(), sr_b.min(), hr_b.min()))
        vmax = float(max(raw_for_range.max(), bic_b.max(), sr_b.max(), hr_b.max()))

        ax0 = fig.add_subplot(gs[i, 0])
        ax1 = fig.add_subplot(gs[i, 1])
        ax2 = fig.add_subplot(gs[i, 2])
        ax3 = fig.add_subplot(gs[i, 3])
        # Force all tiles to fill their subplot cells (same visual size)
        for _ax in (ax0, ax1, ax2, ax3):
            _ax.set_aspect('auto')
        cax = fig.add_subplot(gs[i, 4])

        # Draw images with very small gaps and internal labels
        im0 = _draw(ax0, raw_b, vmin, vmax, f"{col_texts[0]} ({band_text})")
        # Limit the displayed window for GOCI to the ROI using pixel indices
        if goci_roi_box is not None:
            y0, y1, x0, x1 = goci_roi_box
            ax0.set_xlim(x0 - 0.5, x1 + 0.5)
            ax0.set_ylim(y1 + 0.5, y0 - 0.5)  # image origin is top-left
        _draw(ax1, bic_b, vmin, vmax, f"{col_texts[1]} ({band_text})")
        _draw(ax2, sr_b, vmin, vmax, f"{col_texts[2]} ({band_text})")
        im3 = _draw(ax3, hr_b, vmin, vmax, f"{col_texts[3]} ({band_text})")

        # Row marker e.g., (a), (b), ...
        ax0.text(
            0.02,
            0.96,
            f"({chr(97 + i)})",
            transform=ax0.transAxes,
            fontsize=12,
            color="w",
            va="top",
            ha="left",
            path_effects=[
                __import__("matplotlib.patheffects").patheffects.withStroke(linewidth=2, foreground="black")
            ],
            bbox=dict(facecolor="black", alpha=0.35, boxstyle="round,pad=0.2", linewidth=0),
        )

        # Slim colorbar per row
        cb = fig.colorbar(im3, cax=cax)
        cb.ax.tick_params(labelsize=7, pad=1)
        # Thinner outline so it looks lighter
